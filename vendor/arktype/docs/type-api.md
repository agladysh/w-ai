---
title: 'Type API'
source: https://arktype.io/docs/type-api
url: https://arktype.io/docs/type-api
---

[📈 Announcing ArkType 2.1 📈](https://arktype.io/docs/blog/2.1)

# Type API

| Name                | Summary                                                                                                                                           | Notes & Examples                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --- | ----- | --- | ------------------------ | --- | ------------- |
| $                   | [Scope](https://arktype.io/docs/type-api#Scope)<br>in which chained methods are parsed                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| infer               | type of output this returns                                                                                                                       | 🥸 inference-only property that will be `undefined` at runtime<br>`<br>const parseNumber = type("string").pipe(s => Number.parseInt(s))<br>type ParsedNumber = typeof parseNumber.infer // number<br>`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| inferIn             | type of input this allows                                                                                                                         | 🥸 inference-only property that will be `undefined` at runtime<br>`<br>const parseNumber = type("string").pipe(s => Number.parseInt(s))<br>type UnparsedNumber = typeof parseNumber.inferIn // string<br>`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| json                | internal JSON representation                                                                                                                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| toJsonSchema        | generate a JSON Schema                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| meta                | metadata like custom descriptions and error messages                                                                                              | ✅ type<br>[can be customized](https://arktype.io/docs/configuration#custom)<br>for your project                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| description         | human-readable English description                                                                                                                | ✅ works best for primitive values<br>`<br>const N = type("0 < number <= 100")<br>console.log(N.description) // positive and at most 100<br>`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| expression          | syntax string similar to native TypeScript                                                                                                        | ✅ works well for both primitives and structures<br>`<br>const Loc = type({ coords: ["number", "number"] })<br>console.log(Loc.expression) // { coords: [number, number] }<br>`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| assert              | validate and return transformed data or throw                                                                                                     | ✅ sugar to avoid checking for<br>[type.errors](https://arktype.io/docs/type-api#type.errors)<br>if they are unrecoverable<br>`<br>const CriticalPayload = type({<br>    superImportantValue: "string"<br>})<br>// throws TraversalError: superImportantValue must be a string (was missing)<br>const data = CriticalPayload.assert({ irrelevantValue: "whoops" })<br>console.log(data.superImportantValue) // valid output can be accessed directly<br>`                                                                                                                                                                                                                                                                                                                                                                |
| allows              | check input without applying morphs                                                                                                               | ✅ good for stuff like filtering that doesn't benefit from detailed errors<br>```<br>const Numeric = type("number                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | bigint")<br>// [0, 2n]<br>const numerics = [0, "one", 2n].filter(Numeric.allows)<br>``` |
| configure           | add metadata to shallow references                                                                                                                | ⚠️ does not affect error messages within properties of an object<br>`<br>const NotOdd = type("number % 2").configure({ description: "not odd" })<br>// all constraints at the root are affected<br>const odd = NotOdd(3) // must be not odd (was 3)<br>const nonNumber = NotOdd("two") // must be not odd (was "two")<br>const NotOddBox = type({<br>   // we should have referenced notOdd or added meta here<br>   notOdd: "number % 2",<br>// but instead chained from the root object<br>}).configure({ description: "not odd" })<br>// error message at path notOdd is not affected<br>const oddProp = NotOddBox({ notOdd: 3 }) // notOdd must be even (was 3)<br>// error message at root is affected, leading to a misleading description<br>const nonObject = NotOddBox(null) // must be not odd (was null)<br>` |
| describe            | add description to shallow references                                                                                                             | 🔗 equivalent to `.configure({ description })` (see<br>[configure](https://arktype.io/docs/type-api#configure)<br>)<br>⚠️ does not affect error messages within properties of an object<br>`<br>const AToZ = type(/^a.*z$/).describe("a string like 'a...z'")<br>const good = AToZ("alcatraz") // "alcatraz"<br>// ArkErrors: must be a string like 'a...z' (was "albatross")<br>const badPattern = AToZ("albatross")<br>`                                                                                                                                                                                                                                                                                                                                                                                               |
| onUndeclaredKey     | apply undeclared key behavior                                                                                                                     | • `"ignore"` (default) - allow and preserve extra properties<br>• `"reject"` \- disallow extra properties<br>• `"delete"` \- clone and remove extra properties from output                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| onDeepUndeclaredKey | deeply apply undeclared key behavior                                                                                                              | • `"ignore"` (default) - allow and preserve extra properties<br>• `"reject"` \- disallow extra properties<br>• `"delete"` \- clone and remove extra properties from output                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| from                | alias for<br>[assert](https://arktype.io/docs/type-api#assert)<br>with typed input                                                                | `<br>const T = type({ foo: "string" });<br>// TypeScript: foo must be a string (was 5)<br>const data = T.from({ foo: 5 });<br>`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| brand               | add a compile-time brand to output                                                                                                                | 🥸 inference-only function that does nothing runtime<br>`<br>const Palindrome = type("string")<br>    .narrow(s => s === [...s].reverse().join(""))<br>    .brand("palindrome")<br>// Brand<string, "palindrome"><br>const out = Palindrome.assert("racecar")<br>`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| array               | an array of this                                                                                                                                  | `<br>// Type<{ rebmun: number }[]><br>const T = type({ rebmun: "number" }).array();<br>`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| optional            | [optional definition](https://arktype.io/docs/objects#properties-optional)                                                                        | ⚠️ unlike most other methods, this creates a definition rather than a Type (read why)<br>`<br>const Prop = type({ foo: "number" })<br>// Type<{ bar?: { foo: number } }><br>const Obj = type({ bar: Prop.optional() })<br>`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| default             | [defaultable definition](https://arktype.io/docs/objects#properties-defaultable)                                                                  | ✅ object defaults can be returned from a function<br>⚠️ throws if the default value is not allowed<br>⚠️ unlike most other methods, this creates a definition rather than a Type (read why)<br>`<br>// Type<{ count: Default<number, 0> }><br>const State = type({ count: type.number.default(0) })<br>const Prop = type({ nested: "boolean" })<br>const ForObj = type({<br>    key: Prop.default(() => ({ nested: false }))<br>})<br>`                                                                                                                                                                                                                                                                                                                                                                                 |
| filter              | apply a predicate function to input                                                                                                               | ⚠️ the behavior of<br>[narrow](https://arktype.io/docs/type-api#narrow)<br>, this method's output counterpart, is usually more desirable<br>✅ most useful for morphs with input types that are re-used externally<br>🥸<br>[Type predicates](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates)<br>can be used as casts<br>``<br>const stringifyUser = type({ name: "string" }).pipe(user => JSON.stringify(user))<br>const stringifySafe = stringifyUser.filter(user => user.name !== "Bobby Tables")<br>// Type<(In: `${string}Z`) => To<Date>><br>const WithPredicate = type("string.date.parse").filter((s): s is `${string}Z`=><br>    s.endsWith("Z")<br>)<br>``                                                                                                                |
| narrow              | apply a predicate function to output                                                                                                              | ✅ go-to fallback for validation not composable via built-in types and operators<br>✅ runs after all other validators and morphs, if present<br>🥸<br>[Type predicates](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates)<br>can be used as casts<br>```<br>const Palindrome = type("string").narrow(s => s === [...s].reverse().join(""))<br>const PalindromicEmail = type("string.date.parse").narrow((date, ctx) =><br> date.getFullYear() === 2025                                                                                                                                                                                                                                                                                                                               |                                                                                         | ctx.mustBe("the current year")<br>)<br>// Type<`${string}.tsx`><br>const WithPredicate = type("string").narrow((s): s is `${string}.tsx` => /\.tsx?$/.test(s))<br>```                                                                                       |
| pipe                | pipe output through arbitrary transformations or other Types                                                                                      | `<br>const User = type({ name: "string" })<br>// parse a string and validate that the result as a user<br>const parseUser = type("string").pipe(s => JSON.parse(s), user)<br>`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| to                  | parse a definition as an output validator                                                                                                         | 🔗 `to({ name: "string" })` is equivalent to `.pipe(type({ name: "string" }))`<br>`<br>// parse a string and validate that the result as a user<br>const parseUser = type("string").pipe(s => JSON.parse(s)).to({ name: "string" })<br>`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| select              | query internal node references                                                                                                                    | filters and returns the Type's internal representation from `@ark/schema`<br>```<br>// ["blue", "red"]<br>const values = type("'red'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | 'blue'").select("unit").map(u => u.unit)<br>```                                         |
| as                  | cast the way this is inferred                                                                                                                     | 🥸 inference-only function that does nothing runtime<br>``<br>// Type<`LEEEEEEEE${string}ROY`><br>const Leeroy = type(/^LE{8,}ROY$/).as<`LEEEEEEEE${string}ROY`>()<br>``                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| and                 | intersect the parsed Type, throwing if the result is unsatisfiable                                                                                | `<br>// Type<{ foo: number; bar: string }><br>const T = type({ foo: "number" }).and({ bar: "string" })<br>// ParseError: Intersection at foo of number and string results in an unsatisfiable type<br>const Bad = type({ foo: "number" }).and({ foo: "string" })<br>`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| or                  | union with the parsed Type                                                                                                                        | ⚠️ a union that could apply different morphs to the same data is a ParseError (<br>[docs](https://arktype.io/docs/expressions#union-morphs)<br>)<br>```<br>// Type<string                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | { box: string }><br>const T = type("string").or({ box: "string" })<br>```               |
| intersect           | intersect the parsed Type, returning an introspectable<br>[Disjoint](https://arktype.io/docs/type-api#Disjoint)<br>if the result is unsatisfiable | ``<br>// Type<{ foo: number; bar: string }><br>const T = type({ foo: "number" }).intersect({ bar: "string" })<br>const Bad = type("number > 10").intersect("number < 5")<br>// logs "Intersection of > 10 and < 5 results in an unsatisfiable type"<br>if (Bad instanceof Disjoint) console.log(`${bad.summary}`)<br>``                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| equals              | check if the parsed Type's constraints are identical                                                                                              | ✅ equal types have identical input and output constraints and transforms<br>✅ ignores associated<br>[meta](https://arktype.io/docs/type-api#meta)<br>, which does not affect the set of allowed values<br>`<br>const DivisibleBy6 = type.number.divisibleBy(6).moreThan(0)<br>// false (left side must also be positive)<br>DivisibleBy6.equals("number % 6")<br>// false (right side has an additional <100 constraint)<br>console.log(DivisibleBy6.equals("0 < (number % 6) < 100"))<br>const ThirdTry = type("(number % 2) > 0").divisibleBy(3)<br>// true (types are normalized and reduced)<br>console.log(DivisibleBy6.equals(ThirdTry))<br>`                                                                                                                                                                    |
| ifEquals            | narrow this based on an<br>[equals](https://arktype.io/docs/type-api#equals)<br>check                                                             | ✅ ignores associated<br>[meta](https://arktype.io/docs/type-api#meta)<br>, which does not affect the set of allowed values<br>```<br>const N = type.raw(`${Math.random()}`)<br>// Type<0.5>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | undefined<br>const Ez = N.ifEquals("0.5")<br>```                                        |
| extends             | check if this is a subtype of the parsed Type                                                                                                     | ✅ a subtype must include all constraints from the base type<br>✅ unlike<br>[equals](https://arktype.io/docs/type-api#equals)<br>, additional constraints may be present<br>✅ ignores associated<br>[meta](https://arktype.io/docs/type-api#meta)<br>, which does not affect the set of allowed values<br>`<br>type.string.extends("unknown") // true<br>type.string.extends(/^a.*z$/) // false<br>`                                                                                                                                                                                                                                                                                                                                                                                                                   |
| ifExtends           | narrow this based on an<br>[extends](https://arktype.io/docs/type-api#extends)<br>check                                                           | ✅ ignores associated<br>[meta](https://arktype.io/docs/type-api#meta)<br>, which does not affect the set of allowed values<br>```<br>const N = type(Math.random() > 0.5 ? "true" : "0") // Type<0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | true><br>const Ez = N.ifExtends("boolean") // Type<true>                                | undefined<br>```                                                                                                                                                                                                                                            |
| overlaps            | check if a value could satisfy this and the parsed Type                                                                                           | ⚠️ will return true unless a<br>[Disjoint](https://arktype.io/docs/type-api#Disjoint)<br>can be proven<br>```<br>type.string.overlaps("string                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | number") // true (e.g. "foo")<br>type("string                                           | number").overlaps("1") // true (1)<br>type("number > 0").overlaps("number < 0") // false (no values exist)<br>const NoAt = type("string").narrow(s => !s.includes("@"))<br>NoAt.overlaps("string.email") // true (no values exist, but not provable)<br>``` |
| extract             | extract branches<br>[extend](https://arktype.io/docs/type-api#extend)<br>ing the parsed Type                                                      | ```<br>// Type<true                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | 0                                                                                       | 2><br>const T = type("boolean                                                                                                                                                                                                                               | 0   | 'one' | 2   | bigint").extract("number | 0n  | true")<br>``` |
| exclude             | exclude branches<br>[extend](https://arktype.io/docs/type-api#extend)<br>ing the parsed Type                                                      | ```<br>// Type<false                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | 'one'                                                                                   | bigint><br>const T = type("boolean                                                                                                                                                                                                                          | 0   | 'one' | 2   | bigint").exclude("number | 0n  | true")<br>``` |

### [toJsonSchema](https://arktype.io/docs/type-api#tojsonschema)

Each `Type` instance exposes a `toJsonSchema()` method that can be used to generate a corresponding JSON Schema.

```
const User = type({
 name: "string",
 email: "string.email",
 "age?": "number >= 18"
})

const schema = User.toJsonSchema()

const result = {
 $schema: "https://json-schema.org/draft/2020-12/schema",
 type: "object",
 properties: {
  name: { type: "string" },
  email: {
   type: "string",
   format: "email",
   pattern: "^[\w%+.-]+@[\d.A-Za-z-]+\.[A-Za-z]{2,}$"
  },
  age: { type: "number", minimum: 18 }
 },
 required: ["name", "email"]
}
```

Options can be passed to change the behavior including how incompatibilities are handled. See
[the associated config docs](https://arktype.io/docs/configuration#toJsonSchema) for more details.

[prototypes\\ \\ Previous Page](https://arktype.io/docs/configuration#prototypes)
[toJsonSchema\\ \\ Next Page](https://arktype.io/docs/type-api#tojsonschema)
